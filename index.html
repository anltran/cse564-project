<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>CSE 564 Project</title>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <link rel="stylesheet" href="index.css">
</head>
<body>

<div class="main-header">
    <h1>NYC Crime: 2021 to 2024</h1>
    <div class="header-dropdowns">
        <div class="dropdown-group">
            <label for="dropdown">Clustering variable</label>
            <select id="dropdown" oninput="dropdownEvent()"></select>
        </div>
        <button onclick="resetEvent()">Reset All</button>
    </div>
</div>

<div class="main-content">
    <div id="map">
        <p class="instructions">ðŸ›ˆ <i>Click and drag in the map to select NYPD incidents</i></p>
    </div>
    <div class="subgraphs">
        <div id="bar"></div>
        <div id="area"></div>
    </div>
</div>

<script>
    function resetEvent() {
        const map = document.getElementById("map");
        map.innerHTML = '';
        const bar = document.getElementById("bar");
        bar.innerHTML = '';
        const dropdown = document.getElementById("dropdown");
        dropdown.value = 'BORO_NM';
        const area = document.getElementById("area");
        area.innerHTML = '';

        // generate new plots with default variable
        generateMap('BORO_NM');
        generateBarChart('BORO_NM');
        generateAreaChart('BORO_NM');
    }
</script>

<script>

    function generateMap(input, data = null) {
        // plot dimensions and margins
        const margin = {top: 20, right: 10, bottom: 15, left: 0};
        const width = 640 - margin.left - margin.right;
        const height = 640 - margin.top - margin.bottom;

        // create empty plot and append to container div
        const svg = d3.select("#map")
            .append("svg")
                .attr("id", "dot-area")
                .attr("height", "100%")
                .attr("viewbox", `0 0 ${width + margin.left + margin.right} ${width + margin.top + margin.bottom}`)
            .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        function draw(data) {
            // create x-axis
            const x = d3.scaleLinear()
                .domain([-74.3, -73.7])
                .range([0, width]);

            // create y-axis
            const y = d3.scaleLinear()
                .range([height, 0])
                .domain([40.5, 40.9]);

            // color scale
            const color = d3.scaleOrdinal(d3.schemeCategory10)
                .domain(data.map(d => d[input]));

            // generate map points
            const circle = svg.append("g")
                .selectAll("dot")
                .data(data)
                .enter()
                .append("circle")
                    .attr("cx", d => x(d['Longitude']) * (100/640) + "%")
                    .attr("cy", d => y(d['Latitude']) * (100/640) + "%")
                    .attr("r", 1.5)
                    .style("fill", d => color(d[input]))
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");;

            // legend
            const legend = svg.append("g").attr("transform", "translate(20, 20)");

            const legendItems = legend.selectAll(".legend-item")
                .data(color.domain())
                .enter()
                .append("g")
                .attr("class", "legend-item")
                .attr("transform", (d, i) => `translate(0, ${i * 24})`);

            legendItems.append("rect")
                .attr("width", 18)
                .attr("height", 18)
                .attr("fill", color);

            legendItems.append("text")
                .attr("x", 24)
                .attr("y", 9)
                .attr("dy", "0.35em")
                .attr("fill", "black")
                .text(d => d);

            // Add brushing
            svg.call(d3.brush() // Add the brush feature using the d3.brush function
                // .extent( [ [0,0], [width,height] ] ) // initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
                .on("end", updateChart) // Each time the brush selection changes, trigger the 'updateChart' function
            );

            // Function that is triggered when brushing is performed
            function updateChart(event) {
                extent = event.selection
                const dotArea = document.getElementById("dot-area");
                const widthRatio = dotArea.clientWidth/640;
                const heightRatio = dotArea.clientHeight/640;
                if (!extent) {
                    circle.classed("selected", false);
                    var selectedData = null;
                }
                else {
                    circle.classed("selected", function(d){ return isBrushed(extent, x(d.Longitude), y(d.Latitude), widthRatio, heightRatio) } )
                    const selected = d3.selectAll(".selected");
                    var selectedData = selected.data(); // Get the data of the selected elements
                    if (selectedData.length == 0) {
                        selectedData = null;
                    }
                }
                const bar = document.getElementById("bar");
                bar.innerHTML = '';
                generateBarChart(input, selectedData); // Call the bar chart function with the selected data
                const area = document.getElementById("area");
                area.innerHTML = '';
                generateAreaChart(input, selectedData); // Call the area chart function with the selected data
            }

            // A function that return TRUE or FALSE according if a dot is in the selection or not
            function isBrushed(brush_coords, cx, cy, widthRatio, heightRatio) {
                var x0 = brush_coords[0][0] - margin.left,
                    x1 = brush_coords[1][0] - margin.left,
                    y0 = brush_coords[0][1] - margin.top,
                    y1 = brush_coords[1][1] - margin.top;
                var cx = cx * widthRatio;
                var cy = cy * heightRatio;
                return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;    // This return TRUE or FALSE depending on if the points is in the selected area
            }
        }

        if (data != null) {
            draw(data)
        } else {
            // fetch csv data
            d3.csv('http://localhost:3000/data').then(draw)
        }
    }

    generateMap('BORO_NM'); // default variable

</script>

<script>
    const dropdown_variables = [
        'BORO_NM',
        'LAW_CAT_CD',
        'offense',
        'location'
    ];

    // populate dropdown options
    const dropdown = document.getElementById('dropdown');
    dropdown_variables.forEach(element => {
        const option = document.createElement('option');
        option.value = element;
        option.text = element;
        dropdown.appendChild(option);
    });

    // dropdown event handler
    function dropdownEvent() {
        const dropdown = document.getElementById("dropdown");
        const input = dropdown.value;

        // clear plots
        const map = document.getElementById("map");
        map.innerHTML = '';
        const bar = document.getElementById("bar");
        bar.innerHTML = '';
        const area = document.getElementById("area");
        area.innerHTML = '';

        // generate new plots with selected variable
        generateMap(input);
        generateBarChart(input);
        generateAreaChart(input);
    }

</script>

<script>

    function generateBarChart(input, data = null) {
        // plot dimensions and margins
        const margin = {top: 30, right: 20, bottom: 120, left: 60};
        const width = 640 - margin.left - margin.right;
        const height = 400 - margin.top - margin.bottom;

        // create empty plot and append to container div
        const svg = d3.select("#bar")
            .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
            .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        function draw(data) {
            // count the frequency of each categorical value
            const freq = {};
            data.forEach(function(row) {
                freq[row[input]] = (freq[row[input]] || 0) + 1
            })

            // convert the frequency dictionary to the right format
            const mapped = [];
            for (const [key, value] of Object.entries(freq)) {
                mapped.push({
                    var: key,
                    value: value
                })
            }

            // create x-axis
            const x = d3.scaleBand()
                .domain(mapped.map(d => d.var))
                .range([0, width])
                .padding(0.2);

            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x)) 
                .selectAll("text")
                    .attr("transform", "translate(-10,0)rotate(-45)")
                    .style("text-anchor", "end");

            // create y-axis
            const y = d3.scaleLinear()
                .range([height, 0])
                .domain([0, d3.max(mapped, d => d.value)]);

            svg.append("g")
                .call(d3.axisLeft(y));

            // generate bar chart
            svg.selectAll("bar")
                .data(mapped)
                .enter()
                .append("rect")
                    .attr("x", d => x(d.var))
                    .attr("y", d => y(d.value))
                    .attr("width", x.bandwidth())
                    .attr("height", d => height - y(d.value))
                    .attr("fill", "steelblue")
                    .on("mouseover", function(event, d) {
                    if (!d3.select(this).classed("selected")) {
                        d3.select(this).style("fill", "orange");
                    }
                })
                .on("mouseout", function(event, d) {
                    if (!d3.select(this).classed("selected")) {
                        d3.select(this).style("fill", "steelblue");
                    }
                })
                .on("click", function(event, d) {
                    const selection = d3.select(this);
                    if (selection.classed("selected")) {
                        selection.classed("selected", false).style("fill", "steelblue");
                    } else {
                        selection.classed("selected", true).style("fill", "green");
                    }
                    const selectedBars = svg.selectAll("rect.selected");
                    const variables = selectedBars.data().map(d => d.var);

                    filterData = data.filter(d => variables.includes(d[input]))

                    const map = document.getElementById("map");
                    map.innerHTML = '';
                    const area = document.getElementById("area");
                    area.innerHTML = '';
                    generateMap(input, filterData);
                    generateAreaChart(input, filterData);
                });

            // text label for y axis
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Frequency");

            // text label for plot
            svg.append("text")
                .attr("x", (width / 2))             
                .attr("y", 0 - (margin.top / 2) + 2)
                .attr("text-anchor", "middle")
                .style("text-decoration", "underline")  
                .text("Bar Chart of " + input);
        }

        if (data != null) {
            draw(data)
        } else {
            // fetch csv data
            d3.csv('http://localhost:3000/data').then(draw)
        }
    }

    generateBarChart('BORO_NM'); // default variable

</script>

<script>

function generateAreaChart(input, data = null) {
    // plot dimensions and margins
    const margin = {top: 20, right: 10, bottom: 40, left: 60};
    const width = 640 - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;

    // create empty plot and append to container div
    const svg = d3.select("#area")
        .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
        .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    function draw(data) {
        const formatYear = d3.timeFormat("%Y");

        const allCategories = Array.from(new Set(data.map(d => d[input])));
        const allYears = Array.from(new Set(data.map(d => d.year))).sort();

        const grouped = allYears.map(year => {
            const entries = data.filter(d => d.year === year);
            const freq = Object.fromEntries(allCategories.map(c => [c, 0]));
            entries.forEach(d => {
                freq[d[input]]++;
            });
            return { year: d3.timeParse("%Y")(year), ...freq };
        });

        const stack = d3.stack().keys(allCategories);
        const series = stack(grouped);

        const x = d3.scaleTime()
            .domain(d3.extent(grouped, d => d.year))
            .range([0, width]);

        const y = d3.scaleLinear()
            .domain([0, d3.max(series[series.length - 1], d => d[1])])
            .nice()
            .range([height, 0]);

        const color = d3.scaleOrdinal()
            .domain(allCategories)
            .range(d3.schemeCategory10);
        
        const area = d3.area()
            .x(d => x(d.data.year))
            .y0(d => y(d[0]))
            .y1(d => y(d[1]));

        svg.selectAll("path")
        .data(series)
        .join("path")
            .attr("fill", d => color(d.key))
            .attr("class", "area")
            .attr("d", area);

        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x));

        svg.append("g")
            .call(d3.axisLeft(y));

        // text label for x axis
        svg.append("text")
            .attr("transform", "translate(" + (width / 2) + " ," + (height + margin.bottom - 3) + ")")
            .style("text-anchor", "middle")
            .text("Time");

        // text label for y axis
        svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left)
            .attr("x", 0 - (height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text("Frequency");

        // text label for plot
        svg.append("text")
            .attr("x", (width / 2))             
            .attr("y", 0 - (margin.top / 2) + 2)
            .attr("text-anchor", "middle")
            .style("text-decoration", "underline")  
            .text("Area Chart of " + input);

        // legend for plot
        const legend = svg.append("g").attr("transform", "translate(20, 20)");

        const legendItems = legend.selectAll(".legend-item")
            .data(color.domain())
            .enter()
            .append("g")
            .attr("class", "legend-item")
            .attr("transform", (d, i) => `translate(0, ${i * 20})`);

        legendItems.append("rect")
            .attr("width", 18)
            .attr("height", 18)
            .attr("fill", color);

        legendItems.append("text")
            .attr("x", 24)
            .attr("y", 9)
            .attr("dy", "0.35em")
            .text(d => d);
    }

    if (data != null) {
        draw(data)
    } else {
        // fetch csv data
        d3.csv('http://localhost:3000/data').then(draw);
    }
}

generateAreaChart('BORO_NM'); // default variable

</script>

</body>
</html>